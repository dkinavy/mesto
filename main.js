(()=>{"use strict";eval('\n;// CONCATENATED MODULE: ./src/components/Card.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// const imagePopup = document.querySelector(".image-popup");\n// const imagePopupTitle = document.querySelector(".popup__image-title");\nvar Card = /*#__PURE__*/function () {\n  function Card(data, cardSelector, ownerID, _ref) {\n    var handleCardClick = _ref.handleCardClick,\n        handleDeleteCardClick = _ref.handleDeleteCardClick,\n        putLike = _ref.putLike,\n        deleteLike = _ref.deleteLike;\n\n    _classCallCheck(this, Card);\n\n    console.log(data);\n    this._data = data;\n    this._text = data.name;\n    this._image = data.link;\n    this._owner = data.owner._id;\n    this._likesCount = data.likes.length;\n    this._likes = data.likes;\n    this._cardSelector = cardSelector;\n    this._handleCardClick = handleCardClick;\n    this._handleDeleteCardClick = handleDeleteCardClick;\n    this._master = ownerID;\n    this._putLike = putLike;\n    this._deleteLike = deleteLike;\n  }\n\n  _createClass(Card, [{\n    key: "_isOwnCard",\n    value: function _isOwnCard() {\n      if (this._owner !== this._master) {\n        this._element.querySelector(".element__trash").remove();\n      }\n    }\n  }, {\n    key: "deleteCard",\n    value: function deleteCard() {\n      this._element.remove();\n    }\n  }, {\n    key: "_getTemplate",\n    value: function _getTemplate() {\n      var cardElement = document.querySelector(this._cardSelector).content.querySelector(".element").cloneNode(true);\n      return cardElement;\n    }\n  }, {\n    key: "_setEventListeners",\n    value: function _setEventListeners() {\n      var _this = this;\n\n      this._element.querySelector(".element__image").addEventListener("click", function () {\n        return _this._handleCardClick(_this._data);\n      }); //Добавим листнер клика по корзине которая удалит картинку\n\n\n      this._element.querySelector(".element__trash").addEventListener("click", function () {\n        _this._handleDeleteCardClick(_this._data); //evt.target.closest(\'.element\').remove();\n\n      }); // Добавим листнер клика по сердечку который меняет цвет\n\n\n      this._element.querySelector(".element__icon").addEventListener("click", function () {\n        if (!_this._likeButton.classList.contains("element__icon_active")) {\n          _this._putLike(_this._data);\n\n          _this._likeButton.classList.add("element__icon_active"); //               this._likesCount = this._likesCount + 1;\n\n        } else {\n          _this._deleteLike(_this._data); //                this._likesCount = this._likesCount - 1;\n\n\n          _this._likeButton.classList.remove("element__icon_active");\n        }\n      }); // document.addEventListener(\'keydown\', closePopupByEscapePress);\n      // this._element.querySelector(\'.element__image\').addEventListener(\'click\', closePopupByMouseClick);\n\n    }\n  }, {\n    key: "setLikeCount",\n    value: function setLikeCount(count) {\n      console.log(count);\n      this._element.querySelector(".element__like-count").textContent = count;\n    }\n  }, {\n    key: "_isLiked",\n    value: function _isLiked() {\n      var _this2 = this;\n\n      this._likes.forEach(function (likeOwner) {\n        if (likeOwner._id === _this2._master) {\n          _this2._likeButton.classList.add("element__icon_active"); //           return true;\n\n        } //         else return false;\n\n      });\n    }\n  }, {\n    key: "generateCard",\n    value: function generateCard() {\n      this._element = this._getTemplate();\n      this.image = this._element.querySelector(".element__image");\n\n      this._setEventListeners();\n\n      this._likeButton = this._element.querySelector(".element__icon");\n      this.image.src = this._image;\n      this.image.alt = this._text;\n      this._element.querySelector(".element__name").textContent = this._text;\n      this._element.querySelector(".element__like-count").textContent = this._likesCount;\n\n      this._isOwnCard();\n\n      this._isLiked();\n\n      return this._element;\n    } //**Функции лайка, удаления картинки и превью необходимо реализовать в данном классе\n    //Функция переключает вид лайка сердечка\n    //   _toggleIcon(el) {\n    //     el.target.classList.toggle("element__icon_active");\n    //   }\n    // Функция открывает попап с большой картинкой, принимает на вход объект\n    //   _openPopupFullImage() {\n    //     // Присваиваем попапу адрес исходного изображения\n    //     imagePopup.src = this._image;\n    //     // И подпись из карточки\n    //     imagePopupTitle.textContent = this._text;\n    //     //Вызываем универсальную функцию открытия попапа\n    //     openPopup(popupFullimage);\n    //   }\n    // Удаление попапа также реализовано в этом классе\n\n  }]);\n\n  return Card;\n}();\n;// CONCATENATED MODULE: ./src/components/FormValidator.js\nfunction FormValidator_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction FormValidator_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction FormValidator_createClass(Constructor, protoProps, staticProps) { if (protoProps) FormValidator_defineProperties(Constructor.prototype, protoProps); if (staticProps) FormValidator_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar configs = {\n  formSelector: ".popup__form",\n  inputSelector: ".popup__input",\n  submitButtonSelector: ".popup__save",\n  inactiveButtonClass: "popup__save_disabled",\n  inputErrorClass: "popup__input_type_error",\n  errorClass: "popup__error_visible"\n};\nvar FormValidator = /*#__PURE__*/function () {\n  // В конструкторе присвоим классу внутренние поля из конфига\n  function FormValidator(configs, form) {\n    FormValidator_classCallCheck(this, FormValidator);\n\n    this._formSelector = configs.formSelector;\n    this._form = form;\n    this._inputSelector = configs.inputSelector;\n    this._submitButtonSelector = configs.submitButtonSelector;\n    this._inactiveButtonClass = configs.inactiveButtonClass;\n    this._inputErrorClass = configs.inputErrorClass;\n    this._errorClass = configs.errorClass;\n    this._button = this._form.querySelector(this._submitButtonSelector);\n  } //enableValidation теперь будет проще, так как вызывается только для одного объекта\n\n\n  FormValidator_createClass(FormValidator, [{\n    key: "enableValidation",\n    value: function enableValidation() {\n      var _this = this;\n\n      // this._disableButton();\n      this._toggleButtonState();\n\n      this._form.addEventListener("submit", function (evt) {\n        evt.preventDefault();\n\n        _this._disableButton();\n      }); // В установку слушателей тоже не нужно больше пробрасывать переменные, они все есть в объекте\n\n\n      this._setEventListeners();\n    }\n  }, {\n    key: "_setEventListeners",\n    value: function _setEventListeners() {\n      var _this2 = this;\n\n      this._inputs = Array.from(this._form.querySelectorAll(this._inputSelector));\n      this._button = this._form.querySelector(this._submitButtonSelector); // console.log(this._inputs)\n\n      this._isAllValid = this._form.checkValidity();\n\n      this._toggleButtonState();\n\n      this._inputs.forEach(function (input) {\n        input.addEventListener("input", function (evt) {\n          //проверяем на валидность\n          _this2._checkInputValidity(input); //      console.log(input)\n          // меняем состояние кнопки отправки в зависимости от валидности всех инпутов\n\n\n          _this2._isAllValid = _this2._form.checkValidity();\n\n          _this2._toggleButtonState();\n        });\n      });\n    } // Проверяем инпут на валидность, не включаем кастомные тексты ошибок\n\n  }, {\n    key: "_checkInputValidity",\n    value: function _checkInputValidity(input) {\n      if (input.checkValidity()) {\n        //       console.log(input)\n        this._hideError(input);\n      } else {\n        this._showError(input); //   console.log(input)\n\n      }\n    }\n  }, {\n    key: "_showError",\n    value: function _showError(input) {\n      var errorElement = this._form.querySelector("#".concat(input.id, "-error")); // console.log(errorElement)\n\n\n      errorElement.textContent = input.validationMessage;\n      errorElement.classList.add(this._inputErrorClass);\n    } // Убираем текст ошибки если все хорошо\n\n  }, {\n    key: "_hideError",\n    value: function _hideError(input) {\n      var errorElement = this._form.querySelector("#".concat(input.id, "-error"));\n\n      errorElement.textContent = "";\n      errorElement.classList.remove(this._inputErrorClass);\n    } // Меняем состояние кнопки\n\n  }, {\n    key: "_toggleButtonState",\n    value: function _toggleButtonState() {\n      if (this._isAllValid) {\n        this._button.disabled = false;\n\n        this._button.classList.remove(this._inactiveButtonClass);\n      } else {\n        this._disableButton();\n      }\n    }\n  }, {\n    key: "_disableButton",\n    value: function _disableButton() {\n      this._button.disabled = true;\n\n      this._button.classList.add(this._inactiveButtonClass);\n    }\n  }]);\n\n  return FormValidator;\n}();\n;// CONCATENATED MODULE: ./src/components/const.js\n// Коды горячих клавиш должны быть вынесены в константы в отдельный модуль\nvar keys = {\n  esc: "Escape"\n};\n;// CONCATENATED MODULE: ./src/components/Popup.js\nfunction Popup_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Popup_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Popup_createClass(Constructor, protoProps, staticProps) { if (protoProps) Popup_defineProperties(Constructor.prototype, protoProps); if (staticProps) Popup_defineProperties(Constructor, staticProps); return Constructor; }\n\n// класс Popup, который отвечает за открытие и закрытие попапа.\n\nvar Popup = /*#__PURE__*/function () {\n  // Принимает в конструктор единственный параметр — селектор попапа\n  function Popup(popupSelector) {\n    Popup_classCallCheck(this, Popup);\n\n    this._popupSelector = popupSelector;\n    this._popupElement = document.querySelector(this._popupSelector);\n    this._handleClickClose = this._handleClickClose.bind(this);\n    this._handleEscClose = this._handleEscClose.bind(this); //console.log (this._popupElement)\n  } // Содержит публичные методы open и close, которые отвечают за открытие и закрытие попапа.\n\n\n  Popup_createClass(Popup, [{\n    key: "open",\n    value: function open() {\n      this.setEventListeners();\n\n      this._popupElement.classList.add("popup_opened");\n    }\n  }, {\n    key: "close",\n    value: function close() {\n      this._popupElement.classList.remove("popup_opened");\n\n      this.removeEventListeners();\n    } //   Содержит приватный метод _handleEscClose, который содержит логику закрытия попапа клавишей Esc.\n\n  }, {\n    key: "_handleEscClose",\n    value: function _handleEscClose(evt) {\n      if (evt.key === keys.esc) {\n        this.close();\n      }\n    }\n  }, {\n    key: "_handleClickClose",\n    value: function _handleClickClose(evt) {\n      if (evt.target.classList.contains("popup__close") || evt.target.classList.contains("popup")) {\n        this.close();\n      }\n    } //   Содержит публичный метод setEventListeners, который добавляет слушатель клика иконке закрытия попапа\n\n  }, {\n    key: "setEventListeners",\n    value: function setEventListeners() {\n      document.addEventListener("keydown", this._handleEscClose);\n\n      this._popupElement.addEventListener("click", this._handleClickClose);\n    } //1) в классе Popup не исправлено добавление слушателя в методе removeEventListeners\n    // в классе Popup не исправлено добавление и удаление слушателей (все как было на прошлой итерации)\n    // Вот тут забыл bind убрать, ага )\n\n  }, {\n    key: "removeEventListeners",\n    value: function removeEventListeners() {\n      document.removeEventListener("keydown", this._handleEscClose); //this._popupElement.reset();\n\n      this._popupElement.removeEventListener("click", this._handleClickClose);\n    }\n  }]);\n\n  return Popup;\n}();\n;// CONCATENATED MODULE: ./src/components/PopupWithForm.js\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction PopupWithForm_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction PopupWithForm_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction PopupWithForm_createClass(Constructor, protoProps, staticProps) { if (protoProps) PopupWithForm_defineProperties(Constructor.prototype, protoProps); if (staticProps) PopupWithForm_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n// класс PopupWithForm, который наследует от Popup\n\nvar PopupWithForm = /*#__PURE__*/function (_Popup) {\n  _inherits(PopupWithForm, _Popup);\n\n  var _super = _createSuper(PopupWithForm);\n\n  //Кроме селектора попапа принимает в конструктор колбэк сабмита формы\n  function PopupWithForm(popupSelector, _ref) {\n    var _this;\n\n    var submitForm = _ref.submitForm;\n\n    PopupWithForm_classCallCheck(this, PopupWithForm);\n\n    _this = _super.call(this, popupSelector); //Вызываем метод родителя this._popupSelector = popupSelector;\n\n    _this._submitForm = submitForm;\n    _this._form = _this._popupElement.querySelector(\'.popup__form\');\n    _this._inputs = Array.from(_this._form.querySelectorAll(\'.popup__input\'));\n    _this._submitButton = _this._form.querySelector(\'.popup__save\');\n\n    _this._listener = function (evt) {\n      evt.preventDefault();\n\n      _this._submitForm(_this._getInputValues()); //  this.close();\n\n    };\n\n    return _this;\n  } // Содержит приватный метод _getInputValues, который собирает данные всех полей формы.\n  //типа крутим спинер\n\n\n  PopupWithForm_createClass(PopupWithForm, [{\n    key: "loading_on",\n    value: function loading_on() {\n      this._submitButton.textContent = \'Сохранение...\';\n    }\n  }, {\n    key: "loading_off",\n    value: function loading_off() {\n      this._submitButton.textContent = \'Сохранить\';\n    }\n  }, {\n    key: "_getInputValues",\n    value: function _getInputValues() {\n      var inputsData = {}; //  console.log(this._inputs);\n\n      this._inputs.forEach(function (input) {\n        // console.log(input.id);\n        // console.log(input.value);\n        inputsData[input.id] = input.value;\n      }); //console.log(inputsData);\n\n\n      return inputsData;\n    } // Перезаписывает родительский метод setEventListeners. Метод setEventListeners \n    // класса PopupWithForm должен не только добавлять обработчик клика иконке закрытия, \n    // но и добавлять обработчик сабмита формы.\n\n  }, {\n    key: "setEventListeners",\n    value: function setEventListeners() {\n      _get(_getPrototypeOf(PopupWithForm.prototype), "setEventListeners", this).call(this);\n\n      this._form.addEventListener(\'submit\', this._listener);\n    } //Перезаписывает родительский метод close, так как при закрытии попапа форма должна ещё и сбрасываться.\n\n  }, {\n    key: "close",\n    value: function close() {\n      this._form.removeEventListener(\'submit\', this._listener);\n\n      this._form.reset();\n\n      _get(_getPrototypeOf(PopupWithForm.prototype), "close", this).call(this);\n    }\n  }]);\n\n  return PopupWithForm;\n}(Popup);\n;// CONCATENATED MODULE: ./src/components/PopupWithImage.js\nfunction PopupWithImage_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { PopupWithImage_typeof = function _typeof(obj) { return typeof obj; }; } else { PopupWithImage_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return PopupWithImage_typeof(obj); }\n\nfunction PopupWithImage_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction PopupWithImage_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction PopupWithImage_createClass(Constructor, protoProps, staticProps) { if (protoProps) PopupWithImage_defineProperties(Constructor.prototype, protoProps); if (staticProps) PopupWithImage_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction PopupWithImage_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { PopupWithImage_get = Reflect.get; } else { PopupWithImage_get = function _get(target, property, receiver) { var base = PopupWithImage_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return PopupWithImage_get(target, property, receiver || target); }\n\nfunction PopupWithImage_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = PopupWithImage_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction PopupWithImage_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) PopupWithImage_setPrototypeOf(subClass, superClass); }\n\nfunction PopupWithImage_setPrototypeOf(o, p) { PopupWithImage_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return PopupWithImage_setPrototypeOf(o, p); }\n\nfunction PopupWithImage_createSuper(Derived) { var hasNativeReflectConstruct = PopupWithImage_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = PopupWithImage_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = PopupWithImage_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return PopupWithImage_possibleConstructorReturn(this, result); }; }\n\nfunction PopupWithImage_possibleConstructorReturn(self, call) { if (call && (PopupWithImage_typeof(call) === "object" || typeof call === "function")) { return call; } return PopupWithImage_assertThisInitialized(self); }\n\nfunction PopupWithImage_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction PopupWithImage_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction PopupWithImage_getPrototypeOf(o) { PopupWithImage_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return PopupWithImage_getPrototypeOf(o); }\n\n// Создайте класс PopupWithImage, который наследует от Popup\n\nvar PopupWithImage = /*#__PURE__*/function (_Popup) {\n  PopupWithImage_inherits(PopupWithImage, _Popup);\n\n  var _super = PopupWithImage_createSuper(PopupWithImage);\n\n  function PopupWithImage(popupSelector) {\n    PopupWithImage_classCallCheck(this, PopupWithImage);\n\n    return _super.call(this, popupSelector); //Вызываем метод родителя this._popupSelector = popupSelector;\n    // console.log(this._popupImage);\n  } //типа крутим спинер\n\n\n  PopupWithImage_createClass(PopupWithImage, [{\n    key: "loading_on",\n    value: function loading_on() {\n      PopupWithImage_get(PopupWithImage_getPrototypeOf(PopupWithImage.prototype), "_submitButton", this).textContent = \'Сохранение...\';\n    }\n  }, {\n    key: "loading_off",\n    value: function loading_off() {\n      PopupWithImage_get(PopupWithImage_getPrototypeOf(PopupWithImage.prototype), "_submitButton", this).textContent = \'Создать\';\n    } // Этот класс должен перезаписывать родительский метод open\n\n  }, {\n    key: "open",\n    value: function open(image) {\n      // В методе open нужно вставлять в попап картинку и атрибут src изображения и подпись к картинке.\n      var imagePopup = this._popupElement.querySelector(".image-popup");\n\n      imagePopup.src = image.link;\n      imagePopup.alt = image.place;\n      this._popupElement.querySelector(".popup__image-title").textContent = image.place;\n\n      PopupWithImage_get(PopupWithImage_getPrototypeOf(PopupWithImage.prototype), "open", this).call(this);\n    }\n  }]);\n\n  return PopupWithImage;\n}(Popup);\n;// CONCATENATED MODULE: ./src/components/PopupWithDelete.js\nfunction PopupWithDelete_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { PopupWithDelete_typeof = function _typeof(obj) { return typeof obj; }; } else { PopupWithDelete_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return PopupWithDelete_typeof(obj); }\n\nfunction PopupWithDelete_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction PopupWithDelete_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction PopupWithDelete_createClass(Constructor, protoProps, staticProps) { if (protoProps) PopupWithDelete_defineProperties(Constructor.prototype, protoProps); if (staticProps) PopupWithDelete_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction PopupWithDelete_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { PopupWithDelete_get = Reflect.get; } else { PopupWithDelete_get = function _get(target, property, receiver) { var base = PopupWithDelete_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return PopupWithDelete_get(target, property, receiver || target); }\n\nfunction PopupWithDelete_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = PopupWithDelete_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction PopupWithDelete_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) PopupWithDelete_setPrototypeOf(subClass, superClass); }\n\nfunction PopupWithDelete_setPrototypeOf(o, p) { PopupWithDelete_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return PopupWithDelete_setPrototypeOf(o, p); }\n\nfunction PopupWithDelete_createSuper(Derived) { var hasNativeReflectConstruct = PopupWithDelete_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = PopupWithDelete_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = PopupWithDelete_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return PopupWithDelete_possibleConstructorReturn(this, result); }; }\n\nfunction PopupWithDelete_possibleConstructorReturn(self, call) { if (call && (PopupWithDelete_typeof(call) === "object" || typeof call === "function")) { return call; } return PopupWithDelete_assertThisInitialized(self); }\n\nfunction PopupWithDelete_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction PopupWithDelete_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction PopupWithDelete_getPrototypeOf(o) { PopupWithDelete_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return PopupWithDelete_getPrototypeOf(o); }\n\n\nvar PopupWithDelete = /*#__PURE__*/function (_Popup) {\n  PopupWithDelete_inherits(PopupWithDelete, _Popup);\n\n  var _super = PopupWithDelete_createSuper(PopupWithDelete);\n\n  //Кроме селектора попапа принимает в конструктор колбэк сабмита формы\n  function PopupWithDelete(popupSelector, _ref) {\n    var _this;\n\n    var submitForm = _ref.submitForm;\n\n    PopupWithDelete_classCallCheck(this, PopupWithDelete);\n\n    _this = _super.call(this, popupSelector); //Вызываем метод родителя this._popupSelector = popupSelector;\n\n    _this._submitForm = submitForm;\n    _this._form = _this._popupElement.querySelector(".popup__form");\n\n    _this._listener = function (evt) {\n      evt.preventDefault();\n\n      _this._submitForm(_this._data); // this.close();\n\n    };\n\n    return _this;\n  } // Перезаписывает родительский метод setEventListeners. Метод setEventListeners\n  // класса PopupWithForm должен не только добавлять обработчик клика иконке закрытия,\n  // но и добавлять обработчик сабмита формы.\n\n\n  PopupWithDelete_createClass(PopupWithDelete, [{\n    key: "setEventListeners",\n    value: function setEventListeners() {\n      PopupWithDelete_get(PopupWithDelete_getPrototypeOf(PopupWithDelete.prototype), "setEventListeners", this).call(this);\n\n      this._form.addEventListener("submit", this._listener);\n    } // Перезаписывает метод орен так как мы в сабмит должны передать какую конкретную карточку нужно удалять\n\n  }, {\n    key: "open",\n    value: function open(data) {\n      this._data = data;\n\n      PopupWithDelete_get(PopupWithDelete_getPrototypeOf(PopupWithDelete.prototype), "open", this).call(this);\n    }\n  }]);\n\n  return PopupWithDelete;\n}(Popup);\n;// CONCATENATED MODULE: ./src/components/Section.js\nfunction Section_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Section_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Section_createClass(Constructor, protoProps, staticProps) { if (protoProps) Section_defineProperties(Constructor.prototype, protoProps); if (staticProps) Section_defineProperties(Constructor, staticProps); return Constructor; }\n\n//класс Section, который отвечает за отрисовку элементов на странице\nvar Section = /*#__PURE__*/function () {\n  // Уберем передачу списка карточек в момент создания списка карточек. Иначе \n  // потом непонятно как к нему обращаться и как пробрасывать это список\n  function Section(_ref, containerSelector) {\n    var renderer = _ref.renderer;\n\n    Section_classCallCheck(this, Section);\n\n    this._renderer = renderer;\n    this._container = document.querySelector(containerSelector);\n  } //Публичный метод, который отвечает за отрисовку всех элементов. \n  //Отрисовка каждого отдельного элемента должна осуществляться функцией renderer\n\n\n  Section_createClass(Section, [{\n    key: "renderCards",\n    value: function renderCards(items) {\n      var _this = this;\n\n      items.reverse().forEach(function (item) {\n        // console.log(item)\n        _this._renderer(item);\n      });\n    } // Содержит публичный метод addItem, который принимает DOM-элемент и добавляет его в контейнер.\n\n  }, {\n    key: "addItem",\n    value: function addItem(domElement) {\n      this._container.prepend(domElement);\n    }\n  }]);\n\n  return Section;\n}();\n;// CONCATENATED MODULE: ./src/components/UserInfo.js\nfunction UserInfo_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction UserInfo_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction UserInfo_createClass(Constructor, protoProps, staticProps) { if (protoProps) UserInfo_defineProperties(Constructor.prototype, protoProps); if (staticProps) UserInfo_defineProperties(Constructor, staticProps); return Constructor; }\n\n// UserInfo отвечает за управление отображением информации о пользователе на странице.\nvar UserInfo = /*#__PURE__*/function () {\n  // Принимает в конструктор объект с\n  // селекторами двух элементов: элемента имени пользователя и элемента информации о себе.\n  function UserInfo(_ref) {\n    var userNameSelector = _ref.userNameSelector,\n        userJobSelector = _ref.userJobSelector,\n        userAvatarSelector = _ref.userAvatarSelector;\n\n    UserInfo_classCallCheck(this, UserInfo);\n\n    this._userNameSelector = userNameSelector;\n    this._userJobSelector = userJobSelector;\n    this._userAvatarSelector = userAvatarSelector;\n    this._name = document.querySelector(this._userNameSelector);\n    this._job = document.querySelector(this._userJobSelector);\n    this._avatar = document.querySelector(this._userAvatarSelector);\n  } // Содержит публичный метод getUserInfo, который возвращает объект с данными пользователя.\n  // Этот метод пригодится когда данные пользователя нужно будет подставить в форму при открытии.\n\n\n  UserInfo_createClass(UserInfo, [{\n    key: "getUserInfo",\n    value: function getUserInfo() {\n      var userData = {\n        name: this._name.textContent,\n        job: this._job.textContent\n      };\n      return userData;\n    }\n  }, {\n    key: "setUserAvatar",\n    value: function setUserAvatar(info) {\n      this._avatar.src = info.avatar;\n    } // Содержит публичный метод setUserInfo, который принимает новые данные пользователя\n    // и добавляет их на страницу.\n\n  }, {\n    key: "setUserInfo",\n    value: function setUserInfo(info) {\n      console.log(info);\n      this._name.textContent = info.name;\n      this._job.textContent = info.about;\n      this.setUserAvatar(info);\n    }\n  }]);\n\n  return UserInfo;\n}();\n;// CONCATENATED MODULE: ./src/components/Api.js\nfunction Api_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Api_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Api_createClass(Constructor, protoProps, staticProps) { if (protoProps) Api_defineProperties(Constructor.prototype, protoProps); if (staticProps) Api_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Api = /*#__PURE__*/function () {\n  function Api(options) {\n    Api_classCallCheck(this, Api);\n\n    // тело конструктора\n    this.options = options;\n    this._baseUrl = options.baseUrl;\n    this._headers = options.headers;\n  }\n\n  Api_createClass(Api, [{\n    key: "_getResponseData",\n    value: function _getResponseData(res) {\n      if (!res.ok) {\n        return Promise.reject("\\u041E\\u0448\\u0438\\u0431\\u043A\\u0430: ".concat(res.status));\n      }\n\n      return res.json();\n    }\n  }, {\n    key: "getInitialCards",\n    value: function getInitialCards() {\n      return fetch(this._baseUrl + "/cards", {\n        headers: this._headers\n      }).then(this._getResponseData);\n    }\n  }, {\n    key: "getUserInfo",\n    value: function getUserInfo() {\n      return fetch(this._baseUrl + "/users/me", {\n        headers: this._headers\n      }).then(this._getResponseData);\n    } // другие методы работы с API\n\n  }, {\n    key: "setUserInfo",\n    value: function setUserInfo(info) {\n      // console.log(info)\n      return fetch(this._baseUrl + "/users/me", {\n        method: "PATCH",\n        headers: this._headers,\n        body: JSON.stringify({\n          name: info.name,\n          about: info.job\n        })\n      }).then(this._getResponseData);\n    }\n  }, {\n    key: "setUserAvatar",\n    value: function setUserAvatar(avatar) {\n      return fetch(this._baseUrl + "/users/me/avatar", {\n        method: "PATCH",\n        headers: this._headers,\n        body: JSON.stringify({\n          avatar: avatar.link\n        })\n      }).then(this._getResponseData);\n    }\n  }, {\n    key: "addCard",\n    value: function addCard(data) {\n      return fetch(this._baseUrl + "/cards", {\n        method: "POST",\n        headers: this._headers,\n        body: JSON.stringify({\n          name: data.place,\n          link: data.link\n        })\n      }).then(this._getResponseData);\n    }\n  }, {\n    key: "deleteCard",\n    value: function deleteCard(data) {\n      return fetch(this._baseUrl + "/cards/" + data._id, {\n        method: "DELETE",\n        headers: this._headers\n      }).then(this._getResponseData);\n    }\n  }, {\n    key: "deleteLike",\n    value: function deleteLike(data) {\n      return fetch("".concat(this._baseUrl, "/cards/likes/").concat(data._id), {\n        method: "DELETE",\n        headers: this._headers\n      }).then(this._getResponseData);\n    }\n  }, {\n    key: "putLike",\n    value: function putLike(data) {\n      return fetch("".concat(this._baseUrl, "/cards/likes/").concat(data._id), {\n        method: "PUT",\n        headers: this._headers\n      }).then(this._getResponseData);\n    }\n  }]);\n\n  return Api;\n}();\n;// CONCATENATED MODULE: ./src/index.js\n\n // import {Popup} from \'./components/Popup.js\';\n\n\n\n\n\n\n\n\nvar src_configs = {\n  formSelector: ".popup__form",\n  inputSelector: ".popup__input",\n  submitButtonSelector: ".popup__save",\n  inactiveButtonClass: "popup__save_disabled",\n  inputErrorClass: "popup__input_type_error",\n  errorClass: "popup__error_visible"\n}; // Сделаем селекторы для основного окна и для контейнера с карточками\n\nvar container = document.querySelector(".content");\nvar popupImageSelector = ".popup__fullimage";\nvar popupDeleteSelector = ".popup__delete"; // Зададим переменные для попапа профиля\n\nvar buttonOpenProfilePopup = document.querySelector(".profile__edit-button"); // Зададим переменные для нового попапа добавления карточки\n\nvar buttonOpenImagePopup = document.querySelector(".profile__add-button"); // Зададим переменные для нового попапа редактируем аватар\n\nvar buttonOpenAvatarEditPopup = document.querySelector(".profile__avatar-edit-button");\nvar nameInput = document.querySelector(".popup__input_type_name");\nvar jobInput = document.querySelector(".popup__input_type_job");\nvar userNameSelector = ".profile__info-name";\nvar userJobSelector = ".profile__info-title";\nvar userAvatarSelector = ".profile__avatar"; //Инстанцирование данного попапа следует вынести в global \n// scope, чтобы переменная не создавалась каждый раз при вызове данной функции\n\nvar imagePopup = new PopupWithImage(popupImageSelector);\nvar userInfo = new UserInfo({\n  userNameSelector: userNameSelector,\n  userJobSelector: userJobSelector,\n  userAvatarSelector: userAvatarSelector\n});\nvar ownerId = null; //Создадим объект для работы с апи\n\nvar yandex_api = new Api({\n  baseUrl: "https://mesto.nomoreparties.co/v1/cohort-18",\n  headers: {\n    authorization: "a3f1f5fe-630d-4fb3-8d0f-9700ef1ed1ff",\n    "Content-Type": "application/json"\n  }\n}); //Выведем на страницу имя и профессию с сервера\n\nyandex_api.getUserInfo().then(function (data) {\n  userInfo.setUserInfo(data);\n  ownerId = data._id;\n}).catch(function (error) {\n  return console.log(error);\n}); // Процесс создания одной карточки (как в случае, когда мы проходим циклом\n//   по начальным карточкам, так и в случае создания новой карточки) можно\n//   вынести в отдельную функцию (создать можно внутри коллбека then после\n//     ответа сервера, если необходим доступ к полученному ответу оттуда)\n//     и использовать в двух местах - в цикле и в handleFormSubmit попапа\n\nvar createNewCard = function createNewCard(data) {\n  var card = new Card(data, "#element-template", ownerId, {\n    handleCardClick: function handleCardClick(element) {\n      //console.log(element)\n      imagePopup.open(element);\n    },\n    handleDeleteCardClick: function handleDeleteCardClick() {\n      //console.log(element)\n      delitingCard = card;\n      deleteCardPopup.open(data);\n    },\n    putLike: function putLike(data) {\n      yandex_api.putLike(data).then(function (res) {\n        return res.json();\n      }).then(function (res) {\n        // console.log(res);\n        card.setLikeCount(res.likes.length);\n      }).catch(function (err) {\n        console.log(err);\n      });\n    },\n    deleteLike: function deleteLike(data) {\n      yandex_api.deleteLike(data).then(function (res) {\n        return res.json();\n      }).then(function (res) {\n        //  console.log(res);\n        card.setLikeCount(res.likes.length);\n      }).catch(function (err) {\n        console.log(err);\n      });\n    }\n  });\n  return card;\n};\n\nvar cardList = new Section({\n  renderer: function renderer(element) {\n    var card = new createNewCard(element);\n    var cardElement = card.generateCard();\n    cardList.addItem(cardElement);\n  }\n}, ".elements"); //Вызовем метод этого объекта который загружает имеющиеся карты в список\n\nyandex_api.getInitialCards().then(function (data) {\n  // Заполним первоначальные карточки\n  // будем грузить их с сервера\n  //console.log(data);\n  // Отрисуем список\n  cardList.renderCards(data);\n}).catch(function (err) {\n  console.log(err);\n}); //Попап Добавим карточку\n\nvar addCardPopup = new PopupWithForm(".popup__add-card", {\n  submitForm: function submitForm(element) {\n    addCardPopup.loading_on();\n    yandex_api.addCard(element).then(function (res) {\n      return res.json();\n    }).then(function (res) {\n      //  console.log(res);\n      var card = createNewCard(res);\n      var cardElement = card.generateCard();\n      cardList.addItem(cardElement);\n      addCardPopup.close();\n    }).catch(function (error) {\n      return console.log(error);\n    }).finally(function () {\n      addCardPopup.loading_off();\n    });\n  }\n}); //Попап редактируем аватару\n\nvar updateAvatarPopup = new PopupWithForm(".popup__update-avatar", {\n  submitForm: function submitForm(element) {\n    updateAvatarPopup.loading_on();\n    setTimeout(3000); //console.log(element)\n\n    yandex_api.setUserAvatar(element).then(function (res) {\n      return res.json();\n    }).then(function (res) {\n      userInfo.setUserAvatar(res);\n      updateAvatarPopup.close();\n    }).catch(function (err) {\n      console.log(err);\n    }).finally(function () {\n      updateAvatarPopup.loading_off();\n    });\n  }\n}); //Попап с формой удаления карточки\n\nvar delitingCard = null;\nvar deleteCardPopup = new PopupWithDelete(".popup__delete", {\n  submitForm: function submitForm(element) {\n    //К сожалению fetch не пробрасывает ошибку в случае 403\n    //Пол дня убил пытаясь понять почему он не пишет в консоль при попытку удалить чужую картинку\n    yandex_api.deleteCard(element).then(function () {\n      return delitingCard.deleteCard();\n    }).then(function () {\n      return deleteCardPopup.close();\n    }).catch(function (er) {\n      return console.log(er);\n    });\n  }\n}); //Попап с формой редактирования инфы о пользователе\n\nvar popupProfile = new PopupWithForm(".popup__profile", {\n  submitForm: function submitForm(element) {\n    // console.log(element)\n    popupProfile.loading_on();\n    yandex_api.setUserInfo(element).then(function (res) {\n      return res.json();\n    }).then(function (res) {\n      userInfo.setUserInfo(res);\n      popupProfile.close();\n    }).catch(function (error) {\n      return console.log(error);\n    }).finally(function () {\n      popupProfile.loading_off();\n    });\n  }\n}); // Добавим слушатели на кнопки\n\nbuttonOpenProfilePopup.addEventListener("click", function () {\n  //необходимо устанавливать текущие значения имени и профессии пользователя\n  var userData = userInfo.getUserInfo();\n  nameInput.value = userData.name;\n  jobInput.value = userData.job;\n  popupProfile.open();\n});\nbuttonOpenAvatarEditPopup.addEventListener("click", function () {\n  updateAvatarPopup.open();\n});\nbuttonOpenImagePopup.addEventListener("click", function () {\n  return addCardPopup.open();\n}); // создадим валидаторы для всех форм\n\nvar src_forms = Array.from(document.querySelectorAll(src_configs.formSelector)); // Здесь имею в виду, что лучше делать так:\n// const formProfileValidator = new FormValidator(configs, formProfileSelector);\n// formProfileValidator.enableValidation();\n// const formAddCardValidator = new FormValidator(configs, formAddCardSelector);\n// formAddCardValidator.enableValidation(); \n// Вторым аргументом передаем уникальный селектор формы. Таким образом мы имеем независимые экземпляры, с помощью которых можем контролировать состояние каждой формы индивидуально. Например, вызвав formAddCardValidator.toggleButtonState() мы деактивируем кнопку сабмита только для формы добавления карточки. \n// Такое разделение очень полезно и гибко. Сейчас возможно не требуется контролировать состояние форм по отдельности, но при масштабировании проекта - такая возможность может пригодится\n\nvar setFormValidator = function setFormValidator(form) {\n  var formValidator = new FormValidator(src_configs, form);\n  formValidator.enableValidation();\n};\n\nsrc_forms.forEach(function (form) {\n  //  const validator = new FormValidator();\n  setFormValidator(form); // validator.enableValidation();\n});\n\n//# sourceURL=webpack://yandex_praktikum/./src/index.js_+_10_modules?')})();